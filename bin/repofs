#!/usr/bin/env python
#
# Copyright 2017-2021 Vitalis Salis and Diomidis Spinellis
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

import sys
import os
import argparse
import datetime
import fuse
from fuse import FUSE
from pygit2 import clone_repository, Repository, GIT_BRANCH_REMOTE, GIT_MERGE_ANALYSIS_UP_TO_DATE, GIT_MERGE_ANALYSIS_FASTFORWARD, GIT_MERGE_ANALYSIS_NORMAL

fuse.fuse_python_api = (0, 1)

from repofs.repofs import RepoFS


REPOFS_REPOS_DIR = '~/.repofs/repositories/'
REPOFS_MOUNTS_DIR = '~/.repofs/mounts/'


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("uri", help="URI of the Git repository")
    parser.add_argument("--git-path", dest='git_path', help="Path where the Git repository will be cloned.")
    parser.add_argument("--mount-path", dest='mount_path', help="Path where the file system will be mounted.")

    parser.add_argument("--foreground", dest='foreground', help="Allow to execute the tool in foreground mode.", action="store_true")
    parser.add_argument(
        "--hash-trees",
        help="Store 256 entries (first two digits) at each level" \
            "of commits-by-hash for the first three levels.",
        action="store_true",
        default=False
    )
    parser.add_argument(
        "--no-ref-symlinks",
        help="Do not create symlinks for commits of refs.",
        action="store_true",
        default=False
    )
    parser.add_argument(
        "--no-cache",
        help="Do not use the cache",
        action="store_true",
        default=False
    )
    args = parser.parse_args()
    processed_uri = args.uri.lstrip('/')

    git_path = args.git_path
    if not git_path:
        git_path = os.path.join(os.path.expanduser(REPOFS_REPOS_DIR), processed_uri)

    mount_path = args.mount_path
    if not mount_path:
        mount_path = os.path.join(os.path.expanduser(REPOFS_MOUNTS_DIR), processed_uri)
        os.makedirs(mount_path, exist_ok=True)

    if not os.path.exists(git_path):
        clone_repository(args.uri, git_path)
    else:
        repo = Repository(git_path)
        for remote in repo.remotes:
            if remote.name != 'origin':
                continue

            remote.fetch()
            for branch in repo.raw_listall_branches(GIT_BRANCH_REMOTE):
                branch = branch.decode('utf-8')
                if branch.endswith('HEAD') or not branch.startswith('origin/'):
                    continue

                remote_id = repo.lookup_reference('refs/remotes/%s' % (branch)).target
                merge_result, _ = repo.merge_analysis(remote_id)
                if merge_result & GIT_MERGE_ANALYSIS_UP_TO_DATE:
                    continue
                elif merge_result & GIT_MERGE_ANALYSIS_FASTFORWARD:
                    repo.checkout_tree(repo.get(remote_id))
                    try:
                        master_ref = repo.lookup_reference('refs/heads/%s' % (branch))
                        master_ref.set_target(remote_id)
                    except KeyError:
                        repo.create_branch(branch, repo.get(remote_id))
                else:
                    raise AssertionError('Sync failed with upstream')

    sys.stderr.write("Examining repository.  Please wait..\n")
    start = datetime.datetime.now()
    repo = RepoFS(
        repo=os.path.abspath(git_path),
        mount=os.path.abspath(mount_path),
        hash_trees=args.hash_trees,
        no_ref_symlinks=args.no_ref_symlinks,
        no_cache=args.no_cache
    )
    end = datetime.datetime.now()
    sys.stderr.write("Ready! Repository mounted in %s\n" % (end - start))
    sys.stderr.write("Repository %s is now visible at %s\n" % (git_path,
                                                               mount_path))
    FUSE(repo, os.path.abspath(mount_path), nothreads=True, foreground=args.foreground)


if __name__ == '__main__':
    main()
